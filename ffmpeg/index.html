<!DOCTYPE html>
<html>
  <head>
    <title>è§†é¢‘è½¬æ¢</title>
    <meta http-equiv="Cross-Origin-Embedder-Policy" content="require-corp" />
    <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin" />
    <style>
      .progress-container {
        margin: 10px 0;
        padding: 10px;
        background-color: #f0f0f0;
      }
      .status {
        margin: 5px 0;
        font-family: monospace;
        white-space: pre-wrap;
      }
    </style>
  </head>
  <body>
    <h2>è§†é¢‘è½¬æ¢å·¥å…·</h2>
    <input type="text" id="videoInput" />
    <select id="formatSelect">
      <option value="mp4">MP4</option>
      <option value="webm">WebM</option>
    </select>
    <button id="convertBtn">è½¬æ¢</button>

    <div id="progress" class="progress-container"></div>
    <video
      id="outputVideo"
      controls
      style="max-width: 100%; margin-top: 20px"
    ></video>

    <script src="./libs/ffmpeg.min.js"></script>
    <script>
      const { createFFmpeg, fetchFile } = FFmpeg;

      // é…ç½®æœ¬åœ°è·¯å¾„
      const ffmpeg = createFFmpeg({
        log: true,
        corePath: './libs/ffmpeg-core.js',
        wasmPath: './libs/ffmpeg-core.wasm',
        workerPath: './libs/ffmpeg-core.worker.js',
        logger: ({ type, message }) => {
          console.log(`[${type}] ${message}`);
          updateProgress(`[${type}] ${message}`);
        },
      });

      function updateProgress(message) {
        const progressDiv = document.getElementById('progress');
        const messageElement = document.createElement('div');
        messageElement.className = 'status';
        messageElement.textContent = message;
        progressDiv.appendChild(messageElement);
        progressDiv.scrollTop = progressDiv.scrollHeight;
      }

      async function loadFFmpeg() {
        try {
          if (!ffmpeg.isLoaded()) {
            updateProgress('æ­£åœ¨åŠ è½½ FFmpeg...');
            await ffmpeg.load();
            updateProgress('âœ… FFmpeg åŠ è½½å®Œæˆ');
          } else {
            updateProgress('âœ… FFmpeg å·²ç»åŠ è½½');
          }
        } catch (error) {
          updateProgress(`âŒ FFmpeg åŠ è½½å¤±è´¥: ${error.message}`);
          throw error;
        }
      }

      async function convertVideo(inputFile, outputFormat) {
        try {
          // åŠ è½½ FFmpeg
          await loadFFmpeg();

          updateProgress('å†™å…¥è¾“å…¥æ–‡ä»¶...');
          // å†™å…¥è¾“å…¥æ–‡ä»¶
          const inputFileName = `input.${inputFile.name.split('.').pop()}`;
          ffmpeg.FS('writeFile', inputFileName, await fetchFile(inputFile));

          updateProgress('æ‰§è¡Œè½¬æ¢...');
          // æ‰§è¡Œè½¬æ¢å‘½ä»¤
          const outputFilename = `output.${outputFormat}`;

          // ä½¿ç”¨æ›´é€‚åˆçš„ç¼–ç å‚æ•°
          await ffmpeg.run(
            '-i',
            inputFileName,
            '-c:v',
            'libx264',
            '-c:a',
            'aac',
            '-preset',
            'ultrafast', // åŠ å¿«è½¬æ¢é€Ÿåº¦
            '-crf',
            '28', // é™ä½è´¨é‡ä»¥æé«˜é€Ÿåº¦
            '-y', // è¦†ç›–è¾“å‡ºæ–‡ä»¶
            outputFilename
          );

          updateProgress('è¯»å–è¾“å‡ºæ–‡ä»¶...');
          // è¯»å–è¾“å‡ºæ–‡ä»¶
          const data = ffmpeg.FS('readFile', outputFilename);

          updateProgress('åˆ›å»ºç»“æœæ–‡ä»¶...');
          // åˆ›å»ºä¸‹è½½é“¾æ¥
          const blob = new Blob([data.buffer], {
            type: `video/${outputFormat}`,
          });
          const url = URL.createObjectURL(blob);

          updateProgress('âœ… è½¬æ¢å®Œæˆï¼');
          return url;
        } catch (error) {
          updateProgress(`âŒ è½¬æ¢å¤±è´¥: ${error.message}`);
          console.error('è½¬æ¢å¤±è´¥:', error);
          throw error;
        }
      }

      // äº‹ä»¶ç›‘å¬
      document.addEventListener('DOMContentLoaded', () => {
        document
          .getElementById('convertBtn')
          .addEventListener('click', async () => {
            const fileInput = document.getElementById('videoInput').value;
            const formatSelect = document.getElementById('formatSelect');

            if (!fileInput) {
              alert('è¯·é€‰æ‹©è§†é¢‘æ–‡ä»¶');
              return;
            }

            const inputFile = fileInput;
            const outputFormat = formatSelect.value;

            try {
              // æ¸…ç©ºä¹‹å‰çš„è¿›åº¦ä¿¡æ¯
              document.getElementById('progress').innerHTML = '';
              updateProgress('å¼€å§‹è½¬æ¢...');

              const resultUrl = await convertVideo(inputFile, outputFormat);

              // æ˜¾ç¤ºç»“æœè§†é¢‘
              const video = document.getElementById('outputVideo');
              video.src = resultUrl;
              video.style.display = 'block';

              // æä¾›ä¸‹è½½é“¾æ¥
              const downloadLink = document.createElement('a');
              downloadLink.href = resultUrl;
              downloadLink.download = `converted_video.${outputFormat}`;
              downloadLink.textContent = 'ğŸ“¥ ä¸‹è½½è½¬æ¢åçš„è§†é¢‘';
              downloadLink.style.display = 'block';
              downloadLink.style.marginTop = '10px';
              downloadLink.style.padding = '10px';
              downloadLink.style.backgroundColor = '#4CAF50';
              downloadLink.style.color = 'white';
              downloadLink.style.textDecoration = 'none';
              downloadLink.style.borderRadius = '4px';

              document.getElementById('progress').appendChild(downloadLink);
            } catch (error) {
              updateProgress(`âŒ è½¬æ¢å¤±è´¥: ${error.message}`);
            }
          });
      });
    </script>
  </body>
</html>
