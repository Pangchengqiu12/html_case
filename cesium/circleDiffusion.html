<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title></title>
    <script src="./assets/cesium-1.128/Build/CesiumUnminified/Cesium.js"></script>
    <link
      href="./assets/cesium-1.128/Build/CesiumUnminified/Widgets/widgets.css"
      rel="stylesheet"
    />
  </head>
  <style>
    * {
      padding: 0;
      margin: 0;
    }
    #cesiumContainer {
      width: 100%;
      height: 100vh;
    }
  </style>
  <body>
    <div id="cesiumContainer"></div>
    <script type="module">
      // 禁用Ion服务
      Cesium.Ion.defaultAccessToken =
        'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIyMDM0MDc4OC0wY2ViLTRlZDYtYTg5NS01NDcyZGRhN2UxNjIiLCJpZCI6MjUwNjkzLCJpYXQiOjE3Mjk4NDY5MDB9.gRVosLRI5mpNfIR4BATmc-vwgTDS0XixZk4UNyIhZEs';

      let viewer;
      async function initCesium() {
        try {
          viewer = new Cesium.Viewer('cesiumContainer', {
            // terrainProvider: await Cesium.CesiumTerrainProvider.fromUrl(
            //   'http://127.0.0.1:8004/广西桂林七星区地形数据/terrain',
            //   {
            //     requestVertexNormals: true, //开启地形光照
            //   }
            // ),
            animation: false,
            baseLayerPicker: false,
            fullscreenButton: false,
            vrButton: false,
            geocoder: false,
            homeButton: false,
            infoBox: false,
            sceneModePicker: false,
            selectionIndicator: false,
            timeline: false,
            navigationHelpButton: false,
            skyBox: false,
            skyAtmosphere: false,
            shouldAnimate: true,
            contextOptions: {
              webgl: {
                alpha: true,
                failIfMajorPerformanceCaveat: false,
              },
            },
            // imageryProvider: false, //让控制台不报错 默认状态会加载cesium的底图
          });

          viewer.cesiumWidget.creditContainer.style.display = 'none';
          // 添加底图
          // const provider = await Cesium.SingleTileImageryProvider.fromUrl(
          //   'http://127.0.0.1:8004/blue.jpg'
          // );
          // viewer.scene.imageryLayers.addImageryProvider(provider);
          // viewer.scene.imageryLayers.addImageryProvider(
          //   new Cesium.TileMapServiceImageryProvider({
          //     url: 'http://127.0.0.1:8004/map/{z}/{x}/{reverseY}.jpg',
          //     fileExtension: 'jpg',
          //     tilingScheme: new Cesium.GeographicTilingScheme(),
          //     maximumLevel: 7,
          //     minimumLevel: 0,
          //   })
          //   // new Cesium.UrlTemplateImageryProvider({
          //   //   url: 'http://192.168.5.228:8004/map/{z}/{x}/{reverseY}.jpg',
          //   //   fileExtension: 'jpg',
          //   //   tilingScheme: new Cesium.GeographicTilingScheme(),
          //   // })
          // );

          const imgMap = new Cesium.UrlTemplateImageryProvider({
            url:
              'https://t{s}.tianditu.gov.cn/' +
              'DataServer?T=img_w&x={x}&y={y}&l={z}&tk=' +
              '07e1574cc772de3981196a7240279957',
            subdomains: ['0', '1', '2', '3', '4', '5', '6', '7'],
            tilingScheme: new Cesium.WebMercatorTilingScheme(),
            maximumLevel: 18,
          });
          viewer.imageryLayers.addImageryProvider(imgMap);
        } catch (e) {
          console.log(e, 'cesium terrain');
        }
      }
      async function main() {
        await initCesium();
        // loadTileset();
        const circleDiffusion = new CircleDiffusion(viewer);
        circleDiffusion.add([113.944, 22.523, 20], '#F7EB08', 0, 0);
        // circleDiffusion.add([112.31111, 25.09111, 0], '#0000ff', 10000, 10000);
        // viewer.camera.flyTo({
        //   destination: Cesium.Cartesian3.fromDegrees(
        //     112.31111,
        //     25.09111,
        //     10000
        //   ), //设置目标位置:经度度，纬度，高度
        //   orientation: {
        //     heading: Cesium.Math.toRadians(348.4202942851978), // 水平旋转角度
        //     pitch: Cesium.Math.toRadians(-89.74026687972041), // 俯仰角度
        //     roll: Cesium.Math.toRadians(0), // 横滚角度
        //   },
        //   // complete: function callback() {
        //   //   // 定位完成之后的回调函数
        //   // },
        // });
      }
      main();

      /**
       * circleDiffusion：圆扩散
       * 参考gitee上的ts代码
       */

      // 圆扩散
      /**
       * circleDiffusion：圆扩散
       * 参考gitee上的ts代码
       */

      // 圆扩散
      export default class CircleDiffusion {
        viewer;
        lastStageList;
        constructor(viewer) {
          this.viewer = viewer;
          this.lastStageList = [];
          // js语法的每行结尾的“分号”可写可不写
        }
        add(position, scanColor, maxRadius, duration) {
          this.lastStageList.push(
            this.showCircleScan(position, scanColor, maxRadius, duration)
          );
        }
        clear() {
          this.lastStageList.forEach((ele) => {
            this.clearScanEffects(ele);
          });
          this.lastStageList = [];
        }
        /**
         * 圆扩散
         * @param {*} position  扫描中心 如[117.270739,31.84309,32]
         * @param {*} scanColor 扫描颜色 如"rgba(0,255,0,1)"
         * @param {*} maxRadius 扫描半径，单位米 如1000米
         * @param {*} duration 持续时间，单位毫秒 如4000
         */
        showCircleScan(position, scanColor, maxRadius, duration) {
          const cartographicCenter = new Cesium.Cartographic(
            Cesium.Math.toRadians(position[0]),
            Cesium.Math.toRadians(position[1]),
            position[2]
          );
          scanColor = new Cesium.Color.fromCssColorString(scanColor);
          const lastStage = this._addCircleScanPostStage(
            cartographicCenter,
            maxRadius,
            scanColor,
            duration
          );
          return lastStage;
        }
        /**
         * 添加扩散效果扫描线
         * @param {*} cartographicCenter  扫描中心
         * @param {*} maxRadius 扫描半径
         * @param {*} scanColor  扫描颜色
         * @param {*} duration  持续时间
         */
        _addCircleScanPostStage(
          cartographicCenter,
          maxRadius,
          scanColor,
          duration
        ) {
          const _Cartesian3Center =
            Cesium.Cartographic.toCartesian(cartographicCenter);
          const _Cartesian4Center = new Cesium.Cartesian4(
            _Cartesian3Center.x,
            _Cartesian3Center.y,
            _Cartesian3Center.z,
            1
          );
          const _CartograhpicCenter1 = new Cesium.Cartographic(
            cartographicCenter.longitude,
            cartographicCenter.latitude,
            cartographicCenter.height + 500
          );
          const _Cartesian3Center1 =
            Cesium.Cartographic.toCartesian(_CartograhpicCenter1);
          const _Cartesian4Center1 = new Cesium.Cartesian4(
            _Cartesian3Center1.x,
            _Cartesian3Center1.y,
            _Cartesian3Center1.z,
            1
          );
          const _time = new Date().getTime();
          const _scratchCartesian4Center = new Cesium.Cartesian4();
          const _scratchCartesian4Center1 = new Cesium.Cartesian4();
          const _scratchCartesian3Normal = new Cesium.Cartesian3();
          const _this = this;
          const ScanPostStage = new Cesium.PostProcessStage({
            fragmentShader: _this._getScanSegmentShader(),
            uniforms: {
              u_scanCenterEC: function () {
                const temp = Cesium.Matrix4.multiplyByVector(
                  _this.viewer.camera._viewMatrix,
                  _Cartesian4Center,
                  _scratchCartesian4Center
                );
                return temp;
              },
              u_scanPlaneNormalEC: function () {
                const temp = Cesium.Matrix4.multiplyByVector(
                  _this.viewer.camera._viewMatrix,
                  _Cartesian4Center,
                  _scratchCartesian4Center
                );
                const temp1 = Cesium.Matrix4.multiplyByVector(
                  _this.viewer.camera._viewMatrix,
                  _Cartesian4Center1,
                  _scratchCartesian4Center1
                );
                _scratchCartesian3Normal.x = temp1.x - temp.x;
                _scratchCartesian3Normal.y = temp1.y - temp.y;
                _scratchCartesian3Normal.z = temp1.z - temp.z;
                Cesium.Cartesian3.normalize(
                  _scratchCartesian3Normal,
                  _scratchCartesian3Normal
                );
                return _scratchCartesian3Normal;
              },
              u_radius: function () {
                return (
                  (maxRadius * ((new Date().getTime() - _time) % duration)) /
                  duration
                );
              },
              u_scanColor: scanColor,
            },
          });
          this.viewer.scene.postProcessStages.add(ScanPostStage);
          return ScanPostStage;
        }
        /**
         * 扩散效果Shader
         */
        _getScanSegmentShader() {
          const inpram = 18;
          const scanSegmentShader = `
    #version 300 es
    precision highp float;
    in vec2 v_textureCoordinates;
    out vec4 fragColor; // 显式声明输出变量
    uniform sampler2D colorTexture;
    uniform sampler2D depthTexture;
    uniform vec4 u_scanCenterEC;
    uniform vec3 u_scanPlaneNormalEC;
    uniform float u_radius;
    uniform vec4 u_scanColor;

    vec4 toEye(in vec2 uv, in float depth) {
      vec2 xy = vec2((uv.x * 2.0 - 1.0), (uv.y * 2.0 - 1.0));
      vec4 posInCamera = czm_inverseProjection * vec4(xy, depth, 1.0);
      posInCamera = posInCamera / posInCamera.w;
      return posInCamera;
    }

    vec3 pointProjectOnPlane(in vec3 planeNormal, in vec3 planeOrigin, in vec3 point) {
      vec3 v01 = point - planeOrigin;
      float d = dot(planeNormal, v01);
      return (point - planeNormal * d);
    }

    float getDepth(in vec4 depth) {
      float z_window = czm_unpackDepth(depth);
      z_window = czm_reverseLogDepth(z_window);
      float n_range = czm_depthRange.near;
      float f_range = czm_depthRange.far;
      return (2.0 * z_window - n_range - f_range) / (f_range - n_range);
    }

    void main() {
      vec4 color = texture(colorTexture, v_textureCoordinates);
      float depth = getDepth(texture(depthTexture, v_textureCoordinates));
      vec4 viewPos = toEye(v_textureCoordinates, depth);
      vec3 prjOnPlane = pointProjectOnPlane(u_scanPlaneNormalEC, u_scanCenterEC.xyz, viewPos.xyz);
      float dis = length(prjOnPlane - u_scanCenterEC.xyz);

      if (dis < u_radius) {
        float f = 1.0 - abs(u_radius - dis) / u_radius;
        f = pow(f, float(${inpram}));
        color = mix(color, u_scanColor, f);
      }
      fragColor = vec4(color.rgb, color.a * 0.5); // 设置输出颜色，调整透明度
    }
  `;
          return scanSegmentShader;
        }
        /**
         * 清除特效对象
         * @param {*} lastStage 特效对象
         */
        clearScanEffects(lastStage) {
          this.viewer.scene.postProcessStages.remove(lastStage);
        }
      }

      // 使用方法
      // 圆扩散
      // const circleDiffusion = new CircleDiffusion(this.viewer);
      // circleDiffusion.add([113.944, 22.523, 20], "#F7EB08", 800, 9500);
    </script>
  </body>
</html>
