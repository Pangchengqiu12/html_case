<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
          "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/",
          "gsap": "https://cdn.jsdelivr.net/npm/gsap@3.12.5/+esm"
        }
      }
    </script>
    <title>Three.js 扇形圆柱</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      .container {
        width: 100vw;
        height: 100vh;
      }
      .tooltip {
        position: absolute;
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 14px;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s;
        z-index: 10;
      }
    </style>
  </head>
  <body>
    <div class="container"></div>
    <div class="tooltip" id="tooltip"></div>
    <script type="module">
      import * as THREE from 'three';
      import gsap from 'gsap';
      import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

      class Basic {
        dom;
        scene;
        camera;
        renderer;
        controls;

        width;
        height;

        options = {
          data: [
            { name: 'A', value: 100 },
            { name: 'B', value: 200 },
            { name: 'C', value: 300 },
            { name: 'D', value: 400 },
            { name: 'E', value: 500 },
            { name: 'F', value: 600 },
          ],
          outRadius: 300,
          innerRadius: 150, // 改为非0值测试，或设为0
          depth: 100,
          gap: 10, // 扇形分离距离
          color: [
            '#4e9af9',
            '#001529',
            '#0e2a47',
            '#61D6E2',
            '#82C3FF',
            '#FFB042',
          ],
        };
        pieGroup = [];

        constructor(dom) {
          this.dom = dom;
          this.width = this.dom.clientWidth;
          this.height = this.dom.clientHeight;
          this.initScenes();
          this.initData();
          this.setControls();
          this.animate();
          window.addEventListener('resize', () => this.onWindowResize());

          this.raycaster = new THREE.Raycaster();
          this.mouse = new THREE.Vector2();
          this.currentHovered = null;

          this.dom.addEventListener('mousemove', this.onMouseMove.bind(this));
          this.dom.addEventListener('mouseleave', this.onMouseLeave.bind(this));
        }

        initScenes() {
          this.scene = new THREE.Scene();

          this.camera = new THREE.OrthographicCamera(
            -this.width / 2,
            this.width / 2,
            this.height / 2,
            -this.height / 2,
            -1000,
            1000
          );
          this.camera.position.set(0, -1300, 1000);
          this.camera.lookAt(this.scene.position);

          this.renderer = new THREE.WebGLRenderer({
            alpha: true,
            antialias: true,
          });
          this.renderer.setPixelRatio(window.devicePixelRatio);
          this.renderer.setSize(this.width, this.height);
          this.dom.appendChild(this.renderer.domElement);

          const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
          this.scene.add(ambientLight);

          const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
          directionalLight.position.set(-200, 200, 200);
          this.scene.add(directionalLight);
        }

        initData() {
          const data = this.options.data;
          const total = data.reduce((pre, cur) => pre + cur.value, 0);
          const angle = Math.PI * 2; // 360度
          let currentAngle = -Math.PI / 2; // 从顶部开始绘制

          data.forEach((item, index) => {
            const sectorAngle = (item.value / total) * angle; // 当前扇形的角度
            const startAngle = currentAngle;
            const endAngle = currentAngle + sectorAngle;

            item.startAngle = startAngle;
            item.endAngle = endAngle;
            item.color = this.options.color[index];

            console.log(
              `扇形${index}: ${item.name}`,
              ((sectorAngle * 180) / Math.PI).toFixed(1) + '度',
              `颜色: ${item.color}`
            );

            // 计算扇形的中心角度，用于确定分离方向
            const centerAngle = (startAngle + endAngle) / 2;
            this.createPie(startAngle, endAngle, item.color, centerAngle);

            currentAngle = endAngle; // 更新下一个扇形的起始角度
          });
        }

        createPie(startAngle, endAngle, color, centerAngle) {
          const shape = new THREE.Shape();

          // 根据 innerRadius 是否为 0 来决定绘制方式
          if (this.options.innerRadius === 0) {
            // 绘制实心扇形（从圆心开始）
            shape.moveTo(0, 0); // 从圆心开始
            shape.lineTo(
              this.options.outRadius * Math.cos(startAngle),
              this.options.outRadius * Math.sin(startAngle)
            );
            shape.absarc(
              0,
              0,
              this.options.outRadius,
              startAngle,
              endAngle,
              false
            );
            shape.lineTo(0, 0); // 回到圆心
          } else {
            // 绘制环形扇形
            shape.moveTo(
              this.options.innerRadius * Math.cos(startAngle),
              this.options.innerRadius * Math.sin(startAngle)
            );
            shape.lineTo(
              this.options.outRadius * Math.cos(startAngle),
              this.options.outRadius * Math.sin(startAngle)
            );
            shape.absarc(
              0,
              0,
              this.options.outRadius,
              startAngle,
              endAngle,
              false
            );
            shape.lineTo(
              this.options.innerRadius * Math.cos(endAngle),
              this.options.innerRadius * Math.sin(endAngle)
            );
            shape.absarc(
              0,
              0,
              this.options.innerRadius,
              endAngle,
              startAngle,
              true
            );
          }
          shape.closePath();

          const extrudeSettings = {
            curveSegments: 60,
            depth: this.options.depth,
            bevelEnabled: false,
            steps: 2,
          };

          const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
          const material = new THREE.MeshPhongMaterial({
            color: new THREE.Color(color),
            opacity: 1,
            transparent: true,
          });

          const mesh = new THREE.Mesh(geometry, material);

          // 计算分离位移
          const offsetX = Math.cos(centerAngle) * this.options.gap;
          const offsetY = Math.sin(centerAngle) * this.options.gap;
          mesh.position.set(offsetX, offsetY, 0);

          this.scene.add(mesh);
          this.pieGroup.push(mesh);
        }

        setControls() {
          this.controls = new OrbitControls(
            this.camera,
            this.renderer.domElement
          );
          /**
           * enableDamping（启用阻尼）
           * 作用：开启惯性拖拽效果
            true时：松开鼠标后，相机会继续滑动一段距离，模拟物理惯性
            false时：松开鼠标立即停止，没有滑动效果
            体验：设置为 true 会让操作更加丝滑自然
          */
          this.controls.enableDamping = true;
          /**
           * dampingFactor（阻尼系数）
           * 作用：控制惯性拖拽的衰减速度
            数值越小：惯性越强，滑动距离越远，持续时间越长
            数值越大：惯性越弱，滑动距离越短，快速停止
            推荐范围：0.01 ~ 0.2
          */
          this.controls.dampingFactor = 0.05;
          /**
           * enableZoom（启用缩放）
           * 作用：控制是否允许鼠标滚轮缩放
            true时：可以使用鼠标滚轮放大缩小场景
            false时：禁用缩放功能
          */
          this.controls.enableZoom = false;
          /**
           * minDistance & maxDistance（最小/最大距离）
           * 作用：限制相机与目标点的距离范围
            minDistance：最小距离，相机不能拉近到小于这个值
            maxDistance：最大距离，相机不能拉远到大于这个值
          */
          this.controls.minDistance = 100;
          this.controls.maxDistance = 300;
          /**
           * enablePan（启用平移）
           * 作用：控制是否允许鼠标拖动平移场景
            true时：可以使用鼠标拖动来平移场景
            false时：禁用平移功能
          */
          this.controls.enablePan = false;
          /**
           * enableRotate（启用旋转）
           * 作用：控制是否允许鼠标拖动旋转场景
            true时：可以使用鼠标拖动来旋转场景
            false时：禁用旋转功能
          */
          this.controls.enableRotate = false;
        }

        animate = () => {
          requestAnimationFrame(this.animate);
          this.controls.update();
          this.renderer.render(this.scene, this.camera);
        };

        onWindowResize = () => {
          this.width = this.dom.clientWidth;
          this.height = this.dom.clientHeight;
          this.camera.left = -this.width / 2;
          this.camera.right = this.width / 2;
          this.camera.top = this.height / 2;
          this.camera.bottom = -this.height / 2;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(this.width, this.height);
        };
        onMouseMove(event) {
          const rect = this.renderer.domElement.getBoundingClientRect(); //获取元素的位置信息
          this.mouse.x = ((event.clientX - rect.left) / this.width) * 2 - 1; //将鼠标位置映射到[-1,1]的范围
          this.mouse.y = -((event.clientY - rect.top) / this.height) * 2 + 1; //将鼠标位置映射到[-1,1]的范围

          this.raycaster.setFromCamera(this.mouse, this.camera); //将鼠标位置映射到[-1,1]的范围
          const intersects = this.raycaster.intersectObjects(this.pieGroup); //获取鼠标位置与场景中对象的交点
          // 检查是否有交点
          if (intersects.length > 0) {
            // 获取第一个交点的对象
            const object = intersects[0].object;
            // 如果是新的对象，执行hover操作
            if (this.currentHovered !== object) {
              this.onMouseLeave(); // 先清除之前的
              this.currentHovered = object; //更新当前悬停的对象

              gsap.to(object.position, {
                z: 30, //将对象的z轴位置增加30
                duration: 0.3, //动画持续时间
                ease: 'power2.out', //缓动函数
              });

              // 获取数据信息
              const index = this.pieGroup.indexOf(object); //获取对象在饼图组中的索引
              const dataItem = this.options.data[index]; //获取对应的数据项
              this.showTooltip(event, dataItem); //显示提示信息
            }
          } else {
            this.onMouseLeave();
          }
        }

        onMouseLeave() {
          if (this.currentHovered) {
            gsap.to(this.currentHovered.position, {
              z: 0,
              duration: 0.3,
              ease: 'power2.out',
            });
            this.currentHovered = null;
          }
          this.hideTooltip();
        }

        showTooltip(event, dataItem) {
          const tooltip = document.getElementById('tooltip');
          tooltip.innerHTML = `
    <strong>${dataItem.name}</strong><br/>
    值: ${dataItem.value}
  `;
          tooltip.style.opacity = 1;
          tooltip.style.left = event.clientX + 10 + 'px';
          tooltip.style.top = event.clientY + 10 + 'px';
        }

        hideTooltip() {
          const tooltip = document.getElementById('tooltip');
          tooltip.style.opacity = 0;
        }

        destroy() {
          this.controls.dispose();
          this.renderer.dispose();
          while (this.pieGroup.length) {
            const mesh = this.pieGroup.pop();
            this.scene.remove(mesh);
            mesh.geometry.dispose();
            mesh.material.dispose();
          }
          this.dom.removeChild(this.renderer.domElement);
          window.removeEventListener('resize', this.onWindowResize);
        }
      }

      const container = document.querySelector('.container');
      const app = new Basic(container);
    </script>
  </body>
</html>
