<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
          "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/",
          "gsap": "https://cdn.jsdelivr.net/npm/gsap@3.12.5/+esm"
        }
      }
    </script>
    <title>Three.js 扇形圆柱</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      .container {
        width: 50vw;
        height: 500vh;
      }
      .tooltip {
        position: absolute;
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 14px;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s;
        z-index: 10;
      }
    </style>
  </head>
  <body>
    <div class="container"></div>
    <div class="tooltip" id="tooltip"></div>
    <script type="module">
      import * as THREE from 'three';
      import gsap from 'gsap';
      import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

      class Basic3DPie {
        dom;
        scene;
        camera;
        renderer;
        controls;

        width;
        height;
        data = [];

        options = {
          outRadius: 100,
          innerRadius: 80, // 改为非0值测试，或设为0
          depth: 50, //厚度
          gap: 5, // 扇形分离距离
          lineOutLength: 40, // 第一段向外长度
          lineSideLength: 80, // 第二段水平长度
          // color: [
          //   '#3B82F6', // 亮蓝色
          //   '#1E40AF', // 深蓝色
          //   '#60A5FA', // 天蓝色
          //   '#0EA5E9', // 青蓝色
          //   '#22D3EE', // 浅蓝色
          //   '#06B6D4', // 青色
          //   '#38BDF8', // 淡蓝色
          //   '#0369A1', // 靛蓝色
          // ],
          color: [
            ['#3B82F6', '#1E40AF'], // 红色到橙色渐变
            ['#60A5FA', '#0EA5E9'], // 青色到绿色渐变
            ['#3B82F6', '#1E40AF'], // 蓝色到绿色渐变
          ],
        };
        pieGroup = [];

        constructor(dom, options = {}) {
          this.options = { ...this.options, ...options };
          this.dom = dom;
          this.width = this.dom.clientWidth;
          this.height = this.dom.clientHeight;
          this.initScenes();
          this.setControls();
          this.animate();
          window.addEventListener('resize', () => this.onWindowResize());

          this.raycaster = new THREE.Raycaster();
          this.mouse = new THREE.Vector2();
          this.currentHovered = null;

          this.dom.addEventListener('mousemove', this.onMouseMove.bind(this));
          this.dom.addEventListener('mouseleave', this.onMouseLeave.bind(this));
        }

        initScenes() {
          this.scene = new THREE.Scene();

          this.camera = new THREE.OrthographicCamera(
            -this.width / 2,
            this.width / 2,
            this.height / 2,
            -this.height / 2,
            -1000,
            1000
          );
          this.camera.position.set(0, -1300, 1000);
          this.camera.lookAt(this.scene.position);

          this.renderer = new THREE.WebGLRenderer({
            alpha: true,
            antialias: true,
          });
          this.renderer.setPixelRatio(window.devicePixelRatio);
          this.renderer.setSize(this.width, this.height);
          this.dom.appendChild(this.renderer.domElement);

          const ambientLight = new THREE.AmbientLight(0xffffff, 2);
          this.scene.add(ambientLight);

          const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
          directionalLight.position.set(-500, 1000, 800); // x为负(左), y为正(上), z为正(前方)
          this.scene.add(directionalLight);
        }

        setData(data) {
          if (this.data.length > 0) this.removeAllPie();

          this.data = data;
          const total = data.reduce((pre, cur) => pre + cur.value, 0);
          const angle = Math.PI * 2; // 360度
          let currentAngle = -Math.PI / 2; // 从顶部开始绘制

          data.forEach((item, index) => {
            const sectorAngle = (item.value / total) * angle; // 当前扇形的角度
            const startAngle = currentAngle;
            const endAngle = currentAngle + sectorAngle;

            item.startAngle = startAngle;
            item.endAngle = endAngle;
            item.color = this.options.color[index];

            console.log(
              `扇形${index}: ${item.name}`,
              ((sectorAngle * 180) / Math.PI).toFixed(1) + '度',
              `颜色: ${item.color}`
            );

            // 计算扇形的中心角度，用于确定分离方向
            const centerAngle = (startAngle + endAngle) / 2;
            this.createPie(
              startAngle,
              endAngle,
              item.color,
              centerAngle,
              index
            );

            currentAngle = endAngle; // 更新下一个扇形的起始角度
          });
        }
        removeAllPie() {
          this.pieGroup.forEach((item) => {
            this.scene.remove(item);
          });
          this.pieGroup = [];
          this.data = [];
        }

        // 辅助函数：将十六进制颜色转换为RGB
        hexToRgb(hex) {
          const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
          return result
            ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16),
              }
            : null;
        }

        createPie(startAngle, endAngle, color, centerAngle, index) {
          const shape = new THREE.Shape();

          // 根据 innerRadius 是否为 0 来决定绘制方式
          if (this.options.innerRadius === 0) {
            // 绘制实心扇形（从圆心开始）
            shape.moveTo(0, 0); // 从圆心开始
            shape.lineTo(
              this.options.outRadius * Math.cos(startAngle),
              this.options.outRadius * Math.sin(startAngle)
            );
            shape.absarc(
              0,
              0,
              this.options.outRadius,
              startAngle,
              endAngle,
              false
            );
            shape.lineTo(0, 0); // 回到圆心
          } else {
            // 绘制环形扇形
            shape.moveTo(
              this.options.innerRadius * Math.cos(startAngle),
              this.options.innerRadius * Math.sin(startAngle)
            );
            shape.lineTo(
              this.options.outRadius * Math.cos(startAngle),
              this.options.outRadius * Math.sin(startAngle)
            );
            shape.absarc(
              0,
              0,
              this.options.outRadius,
              startAngle,
              endAngle,
              false
            );
            shape.lineTo(
              this.options.innerRadius * Math.cos(endAngle),
              this.options.innerRadius * Math.sin(endAngle)
            );
            shape.absarc(
              0,
              0,
              this.options.innerRadius,
              endAngle,
              startAngle,
              true
            );
          }
          shape.closePath();

          const extrudeSettings = {
            curveSegments: 60,
            depth: this.options.depth,
            bevelEnabled: false,
            steps: 2,
          };

          const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);

          // 创建渐变材质
          let material;
          if (Array.isArray(color) && color.length === 2) {
            // 使用顶点颜色创建逆时针渐变效果
            const vertexColors = [];
            const positions = geometry.attributes.position.array;
            const vertexCount = positions.length / 3;

            // 计算每个顶点的颜色
            for (let i = 0; i < vertexCount; i++) {
              const x = positions[i * 3];
              const y = positions[i * 3 + 1];

              // 计算顶点相对于中心的角度
              let angle = Math.atan2(y, x);

              // 将角度标准化到 [0, 2π] 范围
              if (angle < 0) angle += Math.PI * 2;

              // 计算在扇形角度范围内的进度（逆时针方向）
              let progress = 0;
              const normalizedStartAngle =
                startAngle < 0 ? startAngle + Math.PI * 2 : startAngle;
              const normalizedEndAngle =
                endAngle < 0 ? endAngle + Math.PI * 2 : endAngle;

              if (normalizedEndAngle > normalizedStartAngle) {
                // 正常情况，不跨越0度
                if (
                  angle >= normalizedStartAngle &&
                  angle <= normalizedEndAngle
                ) {
                  progress =
                    (angle - normalizedStartAngle) /
                    (normalizedEndAngle - normalizedStartAngle);
                }
              } else {
                // 跨越0度的情况
                if (
                  angle >= normalizedStartAngle ||
                  angle <= normalizedEndAngle
                ) {
                  if (angle >= normalizedStartAngle) {
                    progress =
                      (angle - normalizedStartAngle) /
                      (2 * Math.PI - normalizedStartAngle + normalizedEndAngle);
                  } else {
                    progress =
                      (2 * Math.PI - normalizedStartAngle + angle) /
                      (2 * Math.PI - normalizedStartAngle + normalizedEndAngle);
                  }
                }
              }

              // 插值计算颜色
              const color1 = this.hexToRgb(color[0]);
              const color2 = this.hexToRgb(color[1]);
              const r = (color1.r + (color2.r - color1.r) * progress) / 255;
              const g = (color1.g + (color2.g - color1.g) * progress) / 255;
              const b = (color1.b + (color2.b - color1.b) * progress) / 255;

              vertexColors.push(r, g, b);
            }

            // 添加顶点颜色属性
            geometry.setAttribute(
              'color',
              new THREE.Float32BufferAttribute(vertexColors, 3)
            );

            material = new THREE.MeshPhongMaterial({
              vertexColors: true,
              opacity: 1,
              transparent: true,
            });
          } else {
            // 单色材质
            material = new THREE.MeshPhongMaterial({
              color: new THREE.Color(color),
              opacity: 1,
              transparent: true,
            });
          }

          const mesh = new THREE.Mesh(geometry, material);

          // 计算分离位移
          const offsetX = Math.cos(centerAngle) * this.options.gap;
          const offsetY = Math.sin(centerAngle) * this.options.gap;
          mesh.position.set(offsetX, offsetY, 0);

          this.scene.add(mesh);
          this.pieGroup.push(mesh);

          //引导线和标签=
          const midAngle = (startAngle + endAngle) / 2;
          const edgeRadius =
            this.options.outRadius + this.options.lineOutLength;
          const topZ = this.options.depth;

          // 起点（扇形顶部边缘）
          const startX = Math.cos(midAngle) * this.options.outRadius;
          const startY = Math.sin(midAngle) * this.options.outRadius;

          // 第一个拐点（向外延伸）
          const midX = Math.cos(midAngle) * edgeRadius;
          const midY = Math.sin(midAngle) * edgeRadius;

          // 末端（水平延伸）
          const endX =
            midX +
            (midX >= 0
              ? this.options.lineSideLength
              : -this.options.lineSideLength);
          const endY = midY;

          const points = [
            new THREE.Vector3(startX, startY, topZ),
            new THREE.Vector3(midX, midY, topZ),
            new THREE.Vector3(endX, endY, topZ),
          ];
          const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
          const lineMaterial = new THREE.LineBasicMaterial({
            color: color[0] || color,
          });
          const line = new THREE.Line(lineGeometry, lineMaterial);
          this.scene.add(line);

          // 创建标签（使用 CanvasTexture）
          const dataItem = this.data[index];
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = 256;
          canvas.height = 64;
          ctx.fillStyle = '#fff';
          ctx.font = '28px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(`${dataItem.name}: ${dataItem.value}`, 128, 32);

          const texture = new THREE.CanvasTexture(canvas);
          const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
          const sprite = new THREE.Sprite(spriteMaterial);
          sprite.scale.set(80, 20, 1); // 控制标签大小
          sprite.position.set(endX, endY + 20, topZ);
          this.scene.add(sprite);
        }

        setControls() {
          this.controls = new OrbitControls(
            this.camera,
            this.renderer.domElement
          );
          /**
           * enableDamping（启用阻尼）
           * 作用：开启惯性拖拽效果
            true时：松开鼠标后，相机会继续滑动一段距离，模拟物理惯性
            false时：松开鼠标立即停止，没有滑动效果
            体验：设置为 true 会让操作更加丝滑自然
          */
          this.controls.enableDamping = true;
          /**
           * dampingFactor（阻尼系数）
           * 作用：控制惯性拖拽的衰减速度
            数值越小：惯性越强，滑动距离越远，持续时间越长
            数值越大：惯性越弱，滑动距离越短，快速停止
            推荐范围：0.01 ~ 0.2
          */
          this.controls.dampingFactor = 0.05;
          /**
           * enableZoom（启用缩放）
           * 作用：控制是否允许鼠标滚轮缩放
            true时：可以使用鼠标滚轮放大缩小场景
            false时：禁用缩放功能
          */
          this.controls.enableZoom = false;
          /**
           * minDistance & maxDistance（最小/最大距离）
           * 作用：限制相机与目标点的距离范围
            minDistance：最小距离，相机不能拉近到小于这个值
            maxDistance：最大距离，相机不能拉远到大于这个值
          */
          this.controls.minDistance = 100;
          this.controls.maxDistance = 300;
          /**
           * enablePan（启用平移）
           * 作用：控制是否允许鼠标拖动平移场景
            true时：可以使用鼠标拖动来平移场景
            false时：禁用平移功能
          */
          this.controls.enablePan = false;
          /**
           * enableRotate（启用旋转）
           * 作用：控制是否允许鼠标拖动旋转场景
            true时：可以使用鼠标拖动来旋转场景
            false时：禁用旋转功能
          */
          this.controls.enableRotate = false;
        }

        animate = () => {
          requestAnimationFrame(this.animate);
          this.controls.update();
          this.renderer.render(this.scene, this.camera);
        };

        onWindowResize = () => {
          this.width = this.dom.clientWidth;
          this.height = this.dom.clientHeight;
          this.camera.left = -this.width / 2;
          this.camera.right = this.width / 2;
          this.camera.top = this.height / 2;
          this.camera.bottom = -this.height / 2;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(this.width, this.height);
        };
        onMouseMove(event) {
          const rect = this.renderer.domElement.getBoundingClientRect(); //获取元素的位置信息
          this.mouse.x = ((event.clientX - rect.left) / this.width) * 2 - 1; //将鼠标位置映射到[-1,1]的范围
          this.mouse.y = -((event.clientY - rect.top) / this.height) * 2 + 1; //将鼠标位置映射到[-1,1]的范围

          this.raycaster.setFromCamera(this.mouse, this.camera); //将鼠标位置映射到[-1,1]的范围
          const intersects = this.raycaster.intersectObjects(this.pieGroup); //获取鼠标位置与场景中对象的交点
          // 检查是否有交点
          if (intersects.length > 0) {
            // 获取第一个交点的对象
            const object = intersects[0].object;
            // 如果是新的对象，执行hover操作
            if (this.currentHovered !== object) {
              this.onMouseLeave(); // 先清除之前的
              this.currentHovered = object; //更新当前悬停的对象

              gsap.to(object.position, {
                z: 30, //将对象的z轴位置增加30
                duration: 0.3, //动画持续时间
                ease: 'power2.out', //缓动函数
              });

              // 获取数据信息
              const index = this.pieGroup.indexOf(object); //获取对象在饼图组中的索引
              const dataItem = this.data[index]; //获取对应的数据项
              this.showTooltip(event, dataItem); //显示提示信息
            }
          } else {
            this.onMouseLeave();
          }
        }

        onMouseLeave() {
          if (this.currentHovered) {
            gsap.to(this.currentHovered.position, {
              z: 0,
              duration: 0.3,
              ease: 'power2.out',
            });
            this.currentHovered = null;
          }
          this.hideTooltip();
        }

        showTooltip(event, dataItem) {
          const tooltip = document.getElementById('tooltip');
          tooltip.innerHTML = `
            <strong>${dataItem.name}</strong><br/>
            值: ${dataItem.value}
          `;
          tooltip.style.opacity = 1;
          tooltip.style.left = event.clientX + 10 + 'px';
          tooltip.style.top = event.clientY + 10 + 'px';
        }

        hideTooltip() {
          const tooltip = document.getElementById('tooltip');
          tooltip.style.opacity = 0;
        }

        destroy() {
          this.controls.dispose();
          this.renderer.dispose();
          while (this.pieGroup.length) {
            const mesh = this.pieGroup.pop();
            this.scene.remove(mesh);
            mesh.geometry.dispose();
            mesh.material.dispose();
          }
          this.dom.removeChild(this.renderer.domElement);
          window.removeEventListener('resize', this.onWindowResize);
        }
      }

      const container = document.querySelector('.container');
      const pie = new Basic3DPie(container);
      pie.setData([
        { name: 'A', value: 100 },
        { name: 'B', value: 200 },
        { name: 'C', value: 300 },
      ]);
    </script>
  </body>
</html>
